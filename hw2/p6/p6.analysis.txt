Alan Cham
HW2 P6

The raw results from the p6.c output are reproduced below:

-------------------------------------------------------------------------
Making raw performance analysis results:
Top    : total runtime (ms)
Bottom : average runtime per iteration (ms)
-------------------------------------------------------------------------
     Iterations     Strategy 1     Stragegy 2     Strategy 3
              1       0.061000    2440.564000      80.336000
                      0.061000    2440.564000      80.336000

             10       0.225000    2441.114000      86.780000
                      0.022500     244.111400       8.678000

            100       1.820000    2441.746000     122.800000
                      0.018200      24.417460       1.228000

           1000      16.913000    2446.206000     512.496000
                      0.016913       2.446206       0.512496

          10000     167.099000    2465.869000    4492.049000
                      0.016710       0.246587       0.449205

         100000    1665.892000    2664.646000   43235.648000
                      0.016659       0.026646       0.432356


Analysis: 
Strategy 1 gives the most consistent performance overall, and it the cost per iteration seems to level out around 0.017 ms, as it hovers around that value when total number of
iterations increase beyond 1000.

Strategy 2 has potential for the best performance, but only if enough iterations are 
performed to amortize the cost of the pointer array creation. The neatest part is that
the cost per iteration seems to scale almost perfectly for the trials I used. Each time
the problem size scales up by a factor of 10, the time per iteration decreases by a 
factor of 10. This just attests to the fact that the first iteration's cost is absolutely
massive compared to subsequent iterations. In all the trials I performed, the total
run time remained almost constant because the cost of subsequent iterations are so
insignificant.

Strategy 3 gives intermediate performance, in the case of a small number of iterations.
It does not perform as well as Strategy 1 but outperforms Strategy 2 at least up to the first 1000 iterations. Strategy 3 seems to scale well for the first 100 iterations, but
the cost per iteration seems to plateau beginning around 1000 iterations. Within the 
trials used in my tests, Strategy3 is the worse performing overall for large number of 
iterations. However, this is very possibly specific to my implementation only.

In theory, marginal cost per subsequent iteration should cost:
  O(log n_1 + log n_2 +...+ log n_k) for Strategy 1.
  O(k) for Strategy 2, since it takes exactly k table lookups
  O(k + log M_0) for Strategy 3, where M_0 is the number of elements in the first array M.